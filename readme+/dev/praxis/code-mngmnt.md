# Code- and coding management

The exponential (and chaotic) growth of software projects in 2000s has founded a "parallel universe" of their organization: requirements/issue tracking, code collecting/versioning, collaboration tools, deployment services, project management.\
Systems, frameworks, methodologies will take some scrolls to name remarkable only.

Admitting the customers/users perspective - "not _how_ but _what_ matters" - draws a distinct watershed: **either** organization serves development, **or** _vice versa_.

## Good organization

Perfect organization endows every process/measure with exact explanation of how does it facilitate development, spare resources, automate routines. (Not because it's a trend or in chosen methodology.)

### Technical advantages

+ Intuitive environment with short learning curves and minor maintenance
+ Limited branching and staging for justified "autonomy" (e.g. branch - for optional/risky features bundle, test/staging system - for dedicated team)
+ Barriers for commits of bad code (copy-paste, guidelines and styles violation, obsolete features, anti-patterns)
+ Eager use of code automation tools (including own frameworks)

#### Advanced
+ Automated workflow of issues (e.g. create tickets from `// ToDo:` or `NotImplementedException` and submit them when coded)

### Behavioral advantages

+ _Processes_ do not suppress direct and casual communication (also with customers and users)
+ Meetings are condensed and limited to involved participants and provide tangible outcomes on code
+ Iteration cycles plan feasible and ponderable results with relatively small organizational overhead
+ Coaching and mentoring for new stuff
