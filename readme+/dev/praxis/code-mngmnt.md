# Code and development management

The exponential (and chaotic) growth of software projects in the 2000s founded a "parallel" ecosystem of their organization: requirements/issue tracking, code collecting/versioning, collaboration tools, deployment services, and project management. Names of involved systems, frameworks, and methodologies will take some screens to name remarkable only.

Admitting the customers/users perspective - "not _how_ but _what_ matters" - draws a distinct watershed: **either** organization serves development, **or** _vice versa_.

## Good organization

Commendable organization endows every process/measure with an exact explanation of how it facilitates development, spares resources, and automates routines. (Not because it's in trends or in chosen methodology.)

### Technical advantages

+ Intuitive environment with short learning curves and minor maintenance.
+ Limited branching and staging for justified "autonomy" (e.g. branch - for optional/risky features bundle, test/staging system - for the dedicated team).
+ Barriers for commits of bad code (copy-pasted, violations of guidelines and styles, obsolete features, anti-patterns).
+ Eager use of code automation tools (including own frameworks).

+ Automated workflow of issues (e.g. create tickets from `// ToDo:` or `NotImplementedException` and submit them when replaced with the code).

### Behavioral advantages

+ _Processes_ do not suppress direct and casual communication (also with customers and users)
+ Meetings are condensed and limited to involved participants and provide tangible outcomes on code
+ Iteration cycles plan feasible and ponderable results with relatively small organizational overhead
+ Coaching and mentoring for new stuff
