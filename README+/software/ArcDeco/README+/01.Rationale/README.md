[![Arc Deco.](../../../../_rsc/_img/ArcDeco/ArcDeco-bar-h33px_rounded.jpg)](../../README.md) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Ü™Ô∏è&nbsp;**Rationale** -> [Big Picture](../02.BigPict/README.md) -> [Stripes](../03.Stripes/README.md) -> [Forces](../04.Forces/README.md) -> [Roles](../05.Roles/README.md) -> [Factors](../06.Factors/README.md) -> [Wrap&nbsp;up](../07.Wrapping/README.md)

---

# Rationale

<details><summary><ins>&nbsp;A chess metaphor you may skip&nbsp;</ins>&nbsp;...</summary>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... but you clicked.

<p dir="rtl">A cherry-picked <b>metaphor</b><br />.simplifies explanation<br />(.At times even for readers)</p>
<b>Chess is a universal metaphor...</b><sup>‚ôüÔ∏è</sup>
<table><tr><td><img alt="&nbsp;IT chess phantasy" src="../../../../_rsc/_img/illus/ChessIT.jpg" /></td><td>
<p>‚ôï‚ôõ Learning the basics of programming is as easy as the rules of the checkered strategy. 
Getting into programming resembles games of neophytes: <i>blitz</i> (wins follow fails), enjoyable, and considerably advancing.</p>

<p>‚ôñ‚ôú Understanding and learning principles and check patterns will prevent blunders but not positional traps of better opponents. 
In like manner, a keen junior will soon write good pieces of code but shaky solutions.</p>

<p>‚ôò‚ôû Then the perception of combinatory vastness and thinking in several moves lifts the curtain of first naive impressions, 
looking beyond which needs a "binocular" of passion and a "torch" of theory.</p>

Here the metaphor breaks down. There's a clear theoretical roadmap and school in chess and the rating will ruthlessly show one's place. In the software, one can be an architect of kludges. 

</td></tr></table>

&nbsp;&nbsp;&nbsp;&nbsp;<sup>‚ôüÔ∏è</sup> <sub>Or we are boring and unimaginative to apply better and smarter analogies. Math theories would set tighter but scare away the majority and I'll be the first to drop (it).</sub>

\_________________________________________________________________________________________________________</details>

There are many ways to <samp><b>ENLIGHTENMENT</b></samp> but from two opposite directions:

<p align="center"><b>E<samp>NTHUSIASM</samp></b> and <b>F<samp>RUSTRATION</samp> &mdash; two sides of the same coin</b></p>

<details><summary>Software experience brings brings both and puts <b>W&thinsp;H&thinsp;Y</b>s MANIFESTO</summary>
</details>

 NEW PRJ WITH SIMPLE DOMAIN STILL NEEDS LEARNING


Why writing cool features doesn't make up a great design. 

Why good design decisions don't survive and those bad ones repeat in the next projects?

Why so many inventions of the WHEEL

ENORM COMBINATORIAL OF ABSTRACTIONS

<p dir="rtl">,Universe&thinsp;<b>&rarr;</b>&thinsp;cosmology<br />,mathematics&thinsp;&rarr;&thinsp;philosophy<br />,physics&thinsp;&#9658;&thinsp;epistemology<br />
,art&thinsp;&#9655;&thinsp;theory<br />, excavation&thinsp;&#9657;&thinsp;anthropology</p>


Any sophisticated subject deserves its study: universe -> cosmology, mathematics -> philosophy, physics -> epistemology, art -> theory, excavations -> anthropology, ... **Software** is not an exception.

## Goal

More practical. A **help**<sup>üôã</sup> to perceive software as a whole continuous "application" of IT pieces of knowledge, rather than tailored scattered occasional craft, or the building of sand castles on greenfields, or the "great art" of perfectionism.

The outcome shall be a better vision and strategy (planning) with less inevitable hacking and voodoo programming.

ELIMINATE THE FEAR

## Other objectives

+ classification
+ roles map and swap


&nbsp;&nbsp;&nbsp;&nbsp;<sup>üôã</sup> <sub>Note the word 'help' - Notes of Arc Deco are neither teaching, nor methodology, nor ideology. At least now.</sub>

## About

Software is a VERY unique product: pure multilevel abstraction but ground to 100% hardware realization in BINARY bits (or qubits someday).

Advanced developers experience delusion and frustration because cutting-edge design decisions don't make up the application's design/architecture.

> WHY EXPERIENCE from BGN doesn't count

THESE abstractions CONTRA  formalize concepts from foreign domains: be it exact science or entertainment.

YOU MAY LIVE HAPPY without thinking. BUT SYSTEMIZE

Is there an abstraction of abstraction? Yes, formalization of software.

Even if the activity's subject (such as software) is mundane, the restricted reflection never harms, especially when intended for practical rewards.

Software is descriptive and agile formalization and coding of variegated extrinsic concepts. It's not manufacturing and is far more abstractive than similar electronics, mechanical engineering, or building.

Being a multilevel projection, fastly implemented over digits and their calculations, the software renders enormous space for utilitarian phantasies and alternativeness of solutions.

## Postulates

+ We think about the software creation as a whole (not some particular applications no matter how complex or big they are).\
(shared inherited acquired experience) (And it's about our practical horizon -- not all software in the world)
+ We treat software creation as definitely the making of new\
(not porting)
* This isn't a methodology, technique, or teaching but trying to clear the obscure _materia_ behind the programming.
* This is a continuous learning where we add layer after layer.
* We will continuously staple our survey to practice, not to end up with classical "I know that I don't know" (Socrates).

---

So, let's roll up our sleeves, take a brush, and with shy strokes put layer after layer on the canvas of software abstractionism:

+ reflection,
+ comprehension,
+ explanation,
+ practical conclusions,
+ application!
+ "derailing" way

( GRAPH STEEP-RAISe-LINE)

\___________

üîö **...** [![Powered by good quotes](https://img.shields.io/badge/üí°Powered-üí¨by_quotes-Cyan?style=flat&labelColor=CornflowerBlue&color=CornflowerBlue)](../../../../pencraft/README+/quotes/README+/cornerstones.md)
&nbsp;üåî (since 2024...)

