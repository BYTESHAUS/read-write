[![Arc Deco.](../../../../_rsc/_img/ArcDeco/ArcDeco-bar-h33px_rounded.jpg)](../../README.md) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚Ü™Ô∏è&nbsp;**Rationale** -> [Big Picture](../02.BigPict/README.md) -> [Stripes](../03.Stripes/README.md) -> [Forces](../04.Forces/README.md) -> [Roles](../05.Roles/README.md) -> [Factors](../06.Factors/README.md) -> [Wrap&nbsp;up](../07.Wrapping/README.md)

---

# Rationale

<details><summary>‚ôüÔ∏è<ins>&nbsp;A chess metaphor you may skip&nbsp;</ins>&nbsp;...</summary>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... but you clicked.

<p dir="rtl">A cherry-picked <b>metaphor</b><br />.simplifies explanation<br />(.At times even for readers)</p>

<table><tr><td><picture><img alt="&nbsp;IT chess phantasy" src="../.jpg" /></picture></td><td>
<p><b>Chess is a universal metaphor.</b><sup>‚ôüÔ∏è</sup> Learning the basics of programming is as easy as the rules of this strategy, and beginning programming resembles games of neophytes: _blitz_ (wins follow fails), enjoyable, and considerably advancing.<br />
&nbsp;&nbsp;&nbsp;&nbsp;<sup>‚ôüÔ∏è</sup> <sub>Or we are boring and unimaginative to apply better and smarter analogies. Math theories would set tighter but would scare away the majority and I'll be the first to drop (it).</sub></p>

<p>Understanding and learning principles and check patterns will prevent blunders but not positional traps of a better opponent. 
In the same way, a keen junior will soon write good pieces of code but failing solutions.</p>

<p>Then the perception of combinatory vastness and thinking in more than one move lifts the curtain of naive impressions, seeing beyond which needs a "binocular" of passion and a torch of theory.</p>
  
</td></tr></table>


Here the metaphor breaks down. There's a clear theoretical roadmap and school in chess and the rating will ruthlessly show one's place. In the software, one can be an architect of kludges. 

\___________</details>

## Why

There are many ways to enlightenment but two directions:

<p align="center"><b>E<samp>NTHUSIASM</samp> and F<samp>RUSTRATION</samp> &mdash; two sides of the same coin</b></p>

## Goal

More practical. A **help**<sup>üôã</sup> to perceive software as a whole continuous "application" of IT pieces of knowledge, rather than tailored scattered occasional craft, or the building of sand castles on greenfields, or the "great art" of perfectionism.

The outcome shall be a better vision and strategy (planning) with less inevitable hacking and voodoo programming.


## Postulates

+ We think about the software creation as a whole (not some particular applications no matter how complex or big they are).\
(shared inherited acquired experience) (And it's about our practical horizon -- not all software in the world)
+ We treat software creation as definitely the making of new\
(not porting)
* This isn't a methodology, technique, or teaching but trying to clear the obscure _materia_ behind the programming.
* This is a continuous learning where we add layer after layer.
* We will continuously staple our survey to practice, not to end up with classical "I know that I don't know" (Socrates).

---

So, let's roll up our sleeves, take a brush, and with shy strokes put layer after layer on the canvas of software abstractionism:

+ reflection,
+ comprehension,
+ explanation,
+ practical conclusions,
+ application!
+ "derailing" way

\___________\

üîö **...** [![Powered by good quotes](https://img.shields.io/badge/üí°Powered-üí¨by_quotes-Cyan?style=flat&labelColor=CornflowerBlue&color=CornflowerBlue)](../../../../pencraft/README+/quotes/README+/cornerstones.md)
&nbsp;üåî (since 2024...)

