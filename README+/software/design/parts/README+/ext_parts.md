# Software &nbsp;&mdash;&nbsp; External parts

What are the cornerstones of a big new project &thinsp;&mdash;&thinsp; technologies, tools, requirements, planning, team, and budget? Neither. \
**The fundamentals already exist and are proven concepts/components to adopt.**

> **This follows the universal paradigm: learn first from others.**

Full-fledged third-party frameworks, libraries, and services allow developers to focus on application business and UX rather than tame technologies, type and maintain tons of boilerplate code; test, find, and fix extra bugs.<sup>ðŸ™‹</sup>

&nbsp; &nbsp; &nbsp; &nbsp; <sup>:raising_hand:</sup> <samp>I like their pragmatic and eloquent motto Â«_We are your extended team_Â» (DevExpress).</samp>

Such external parts are often a click away from evaluation and range:

* **from** solo algorithm **to** browser engine (the latter is surprisingly easier to borrow),
* **from** built-in source code **to** remote black-box service,
* **from** lib calls **to** injecting into frameworks,
* **from** open source or/and free **to** commercial and obfuscated,

Even great enterprises are reluctant to create the parts from the ground up and re-invent the wheel (unless it's rounder than others or "security first" rules).

## Core components

Integration of video/image-processing/3D/browsing/search in custom applications is chiefly organic and indisputable.

The same applies to text editors.

## Frontend

Downright a must, and an acute demand met by more than experienced providers of suites, frameworks, and controls for Rapid Application Development: Telerik, DevExpress, Google, and Infragistics - to name a few.

Developers get the best out-of-the-box: state-of-the-art UI, professional look and feel, binding logical classes to place onto Model/ViewModel/Controller (with _table_ as the finest demonstrator).

## Backend

Simple to moderate applications need no elaborate structure - they begin with a few data context classes. For large projects, teams shall weigh evaluation, learning curve, and fitting of the chosen framework against the hardship of their own development.

Many frameworks are good in themselves, but will burden your project with too much unclaimed "ballast" code.

## Testing

Components for testing are so organic for applications that are associated/integrated with popular languages/platforms/IDEs (Java, Angular) and DevOps. Their state for .NET got a piece of discussion in [C# nice-to-have](../../../../../README+/.net/README+/parts/cs-lacks-parts.md#testing).

## Selection

### Free and open source

Some non-commercial projects launched by individuals or groups have grown to industry standards and been adopted in mainstream languages. Recall [Newton.json](https://www.newtonsoft.com/json)<sup>ðŸ”—</sup> that has filled the JSON blank in C# for years.
 
Most license allow commercial use but when applying such 3d-party assets consider if there's a community (maybe, only you) able to maintain the stuff within the lifecycles of dependent projects. 
Thus the readable source code with transparent design concepts is above all: releases, active contributors, extra features, popularity.

Also, freeware means pretty often open-source, and here, not all are ready to give out the best ideas and realizations.

### commercial and proprietary

All-around pro solutions aren't free, but annual dev licenses below $1K will quickly pay off even for a humble undertaking. Let alone live support and membership in a durable, motivated community.&nbsp;<sup>:raising_hand:</sup>

&nbsp; &nbsp; <sup>:raising_hand:</sup> <samp>Compare to the exciting accomplished but then abandoned [Iron Python](https://ironpython.net/)<sup>ðŸ”—</sup> or prominent test mocks ... last updated 10 years ago.</samp>

___________\
ðŸ”š .. 2024-2025 ..
