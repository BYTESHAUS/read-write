<h1 align="center"><samp>SOFTWARE CREATION</samp> &nbsp;&rarr;&nbsp; ⚙️D&thinsp;r&thinsp;i&thinsp;v&thinsp;e&thinsp;s⚙️</h1>

> ### What guides programming minds (and how) is a separate IT discipline. _Test-Driven Development_, _Domain-Driven Design_, and _Event-Driven Architecture_ are only a few household names. 

<h3 align="right">Even <i>functional programming</i> is a driven approach.</h3>

<details align="center"><summary><h3><ins>&nbsp;<b>Fancying more items on both sides of <samp>DRIVEN</samp> will scheme a grotesque gearbox&thinsp;:</b>&thinsp;</ins></h3>&nbsp;⬇️</summary>
<br />
<p align="center"><picture><img alt="&thinsp;&nbsp; Combinational mess of drives and driven" src="../../../_rsc/_img/illus/AllDrives.jpg"/></picture></p>
</details>

<p align="center">⬆️&thinsp;<mark><b>Let's figure out what to do with this mess...</b>&thinsp;⬇️</mark></p>

# _Drive_, let _drive_, and let be _driven_

Let's reserve individual surveys of <ins><b>&thinsp;<samp>ONE-WAY</samp> 1&thinsp;:&thinsp;1&thinsp;</b></ins> to voluminous books and techno-evangelists. They do a great job of formalization (including methodologies) and popularizing exclusive approaches, which may prevail in particular initiatives.

Let's be free of dogmas and  isolated combinations. The easiest path is to conjure up the items (from the picture above) around a task and develop it with approaches in mind.<sup>🙋</sup>

The arduous task is to draw arrows in the picture,  play with their direction, and prioritize (this also means erasing some). Then continue designing names, categories, and programmatic structures.

\_______\
&nbsp; &nbsp; &nbsp;<sup>🙋</sup> <samp>This read isn't a doctrine yet. You are free to dump it now (unless you want to spare hours of rambling in courses and books.</samp>

## Our gearbox has &nbsp; .&thinsp;.&thinsp;.&nbsp; <samp>R&thinsp;E&thinsp;V&thinsp;E&thinsp;R&thinsp;S&thinsp;E</samp>

Consider any approach's counter "rotation," regardless of how twisted it looks first. For example, _Development-Driven Tests_ are nothing else than **test coverage** (e.g., for planning and automation).

<samp><b>REVERSE ENGINEERING</b></samp> is ... _Code-Driven-Design_, and _Design Driven Requirements_ can be percieved as Documentation.

🚧🚧🚧... more EXAMPLES coming ... 🚧🚧🚧

## Filter out...

For any particular application, some drives will drop out themselves (like UX for DB), but not all the remaining combinations will drive, and some may be detrimental.

For example, Development Driven/Crippled Design from the gross use of _Test Driven Development_.

#  Domain drive

## ... for all

<table><tr valign="top"><td width="25%"><picture>
  <img alt="&nbsp;Snapshot of illustrated kids alphabet" src="../../../_rsc/_img/illus/freepik.com-KidsAbc.jpg" title="&nbsp;courtesy of FREEP!K&#013;&#010;(freepik.com)" />
</picture><br />
<i>Bounded Contexts</i>
</td><td>
  
If <i>domain-driven</i> is a distinct approach, there must be alternatives without that. And I <b>doubt there are</b>...

### Software as a phenomenon abstracts domains, explicitly or implicitly. _Domain Drive_ is a permanent force (like the gravitation of abstractions).

One of the motives and benefits of object-oriented design is that it directly maps to domains, though one may break it with wrong and overladen hierarchies and bad naming.

<blockquote><p>DDD-tempered code is adverse to names such as <code>utility</code>, <code>service</code>, <code>handler</code>, or <code>data</code> (unless these are conventions of platforms/frameworks).</p></blockquote>

<p align="center"><b>I can't help bringing even more heresy:</b></p>

<b>D&thinsp;D&thinsp;D&thinsp;</b> is so innate that studying it is like learning the alphabet of spoken tongues. Flipped in the mirror and with a deep analysis of segments.
</td></tr></table>

### R&thinsp;E&thinsp;V&thinsp;E&thinsp;R&thinsp;S&thinsp;E&nbsp; there?

**<mark>&thinsp;Y&thinsp;e&thinsp;s&thinsp;</mark>**, remember the aphorism «_Computers solve problems that we didn't have without them_»? That's definitely about _Operating Systems_ - the product of <i><b>Hardware</b></i>&<i><b>Software</b>-Driven-Domain</i>.

Many other systems are projections of rudimentary software possibilities before large-scale computerization: social networks, email, and blockchains. And less corresponding to the term 
<span title="&nbsp;Content Management System"><ins>CMS</ins></span>, <span title="&nbsp;Customer Relationship Management "><ins>CRM</ins></span>, and <span title="&nbsp;Erterpise Resource Planning"><ins>ERP</ins></span> (as SAP).

<table><tr><td>☝️</td><td>

### Reverse D&thinsp;D&thinsp;D isn't the thing of exotic projects with a "remake" of legacy software as an archetype.

<p>You may recall success stories when leading-edge IT platforms inspired ideas, use cases, and features that had never been discussed before, and users/customers loved them .</p>
</td></tr></table>

# Test drive

**T&thinsp;D&thinsp;D** is the oldest, still most talked over and practiced approach and earned its own corner, even the HALL❗, in the [**Tests area**](../../tests).

### To digest

1) Test Driven **Development** and Test Driven **Design** are branching approaches.
2) Tests better qualify not as drives but as tools for Driven Development and Design.


# Appendix. Developer-friendly design

## Builder&thinsp;/&thinsp;Wizard-based design

🚧 ... TO WRITE ... 🚧

Example:\
|- use-dev➡️ [Wizard blocks](https://github.com/byteshaus/use-dev/blob/main/src/TuttiFrutti/WizConstr/README.md)

\___________\
🔚 <sub> ..2024-2025 ... borrowed images credit: [The Outer Limits.The&nbsp;Mutant, 1964](https://www.imdb.com/title/tt0667845/?ref_=ttep_ep25), [FREEP1K](FREEP!K (freepik.com))</sub>
