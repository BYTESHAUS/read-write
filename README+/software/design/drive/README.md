# Software creation &mdash; Drives

What guides programming minds (and how) is a separate IT discipline. _Test Driven Development_, _Domain Driven Design_, and _Event-Driven Architecture_ are only a few household names for approaches.

<details><summary><ins>&nbsp;<b>Adding more subject titles and trying to combine them will paint a messy picture:</b>&nbsp;</ins></summary>
&nbsp;
  
<picture><img alt="&thinsp;&nbsp;&nbsp;Combinational mess of drives and driven" src="../../../_rsc/_img/illus/AllDrives.jpg"/></picture>

\___________
</details>

## Drive and let drive

Let's reserve <mark>one-way <b>1&thinsp;:&thinsp;1</b></mark> to voluminous books and evangelists &mdash; they do a great job of defining methodology and popularizing exclusive approaches, which may prevail in particular initiatives but can't be single in real development.

Our path to enlightenment is not to be dogmatic and stick to isolated combinations.

### None and all

1:1

### Reverse to switch

ToDo: // ILLUSTRATION W/ BOOKs

###  Domain drive ... for all

_Domain-driven_ as a distinct approach must assume that there are alternatives without that. I doubt there are. Software as a phenomenon abstracts domains. explicitly or implicitly DD is a permanent force.

One can't avoid DDD, but only break it with over-hierarchies and bad naming.

> DDD-tempered code is adverse to naming like `utility`, `service`, `handler`, or `data` (unless conventions of platforms/frameworks).

#### ... reverse ?? driven domain

yes. 

SAP, ERP. E-Mail as an example

### Tests as providers

Testing was a pioneer methodology in driven dev and design.

#### Wrap up

- Further:\
--- [Tests as drive](../../tests/asDrive)

ðŸ”š
