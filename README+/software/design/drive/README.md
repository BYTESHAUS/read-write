# Software creation &mdash; Drives

What guides programming minds (and how) is a separate IT discipline. _Test Driven Development_, _Domain Driven Design_, and _Event-Driven Architecture_ are only a few household names for approaches.

<details><summary><ins>&nbsp;<b>Adding more subjects and trying to combine them will roughly scheme a grotesque gearbox:</b>&nbsp;</ins></summary>
&nbsp;
  
<picture><img alt="&thinsp;&nbsp;&nbsp;Combinational mess of drives and driven" src="../../../_rsc/_img/illus/AllDrives.jpg"/></picture>

\___________
</details>

## Drive and let drive

Let's reserve <mark>&thinsp;one-way <b>1&thinsp;:&thinsp;1&thinsp;</b></mark> to voluminous books and techno-evangelists &mdash; they do a great job of formalization (including methodologies) and popularizing exclusive approaches, which may prevail in particular initiatives but can't be self-contained on praxis.

Our objective is to be neither dogmatic nor sticky to isolated combinations. The easiest path is to imagine the items (from the picture above) around your task and develop with approaches in mind.

The arduous trail is to draw arrows in the picture, play with their direction, and prioritize. Then continue with design naming and structures.

### Consider <samp>REVERSE</samp>

For any approach consider its reverse "rotation", regardless of how fantastically it looks. For example, _Development-Driven-Tests_ are nothing else than test coverage and automation.

<samp>REVERSE ENGINEERING</samp> is ... guess what - ... Code-Driven-Design, or REQS BUILD!

ðŸš§ðŸš§ðŸš§... MORE EXAMPLES ... ðŸš§ðŸš§ðŸš§

###  Domain drive ... for all

_Domain-driven_ as a distinct approach must assume that there are alternatives without that. **I doubt there are** &mdash; software as a phenomenon abstracts domains, explicitly or implicitly, nothing else. Domain Drive is a permanent force (like gravitation of abstractions).

One of the motivations and benefits of object-oriented design is that it directly maps to domains, though one may break it with over-hierarchies and bad naming.

> DDD-tempered code is adverse to the naming such as `utility`, `service`, `handler`, or `data` (unless these are conventions of platforms/frameworks).

#### ... <samp>REVERSE</samp> there?

**Yes**, and it's not software as a domain or dev tools (as IDEs aren't the case).

Computers facilitated the BIZ UNTHINKABL before. Take resource management, WHAT ELSE, . E-Mail as an example. Or quite recent - BLOCKCHAIN

### Tests as providers

Tests Driven Development is the OLDEST (LINKE TO THE ARTICLE) and most PROMINENT title ... BUT ... !

Testing was a pioneer methodology in driven dev and design.

1) D not D;
2) isn't drive but tool
 [Tests as drive](../../tests/asDrive)

#### Wrap up

This was a sketch, that shall be enhanced with references to on-practice projects. Neverheless, it might have spared you hours of rambling in courses and books.

ðŸ”š <sub>// image credit: [The Outer Limits.The&nbsp;Mutant, 1964](https://www.imdb.com/title/tt0667845/?ref_=ttep_ep25)</sub>
