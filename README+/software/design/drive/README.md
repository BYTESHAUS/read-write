# Software creation &mdash; Drives

What guides programming minds (and how) is a separate IT discipline. _Test-Driven Development_, _Domain-Driven Design_, and _Event-Driven Architecture_ are only a few household names for approaches. Functional programming is also a driven approach.

<details><summary><ins>&nbsp;<b>Imagining more items on both sides of DRIVEN will  scheme a grotesque gearbox:</b>&nbsp;</ins></summary>
&nbsp;
  
<picture><img alt="&thinsp;&nbsp;&nbsp;Combinational mess of drives and driven" src="../../../_rsc/_img/illus/AllDrives.jpg"/></picture>

\___________
</details>

What for?

## Drive and let drive

Let's reserve individual surveys of <mark>&thinsp;one-way <b>1&thinsp;:&thinsp;1&thinsp;</b></mark> to voluminous books and techno-evangelists. They do a great job of formalization (including methodologies) and popularizing exclusive approaches, which may prevail in particular initiatives.

Let's be free of dogmas and  isolated combinations. The easiest path is to imagine the items (from the picture above) around a task and develop it with approaches in mind.

The arduous trail is to draw arrows in the picture,  play with their direction, and prioritize (this also means erasing some). Then continue designingnaming and structures.

### Shift <samp>REVERSE</samp>

Consider any approach's counter "rotation," regardless of how twisted it looks first. For example, Development-Driven Tests are nothing more than test coverage (for automation).

<samp>REVERSE ENGINEERING</samp> is ... Code-Driven-Design! Design Driven Requirements makes Documentation.

ðŸš§ðŸš§ðŸš§... more EXAMPLES coming ... ðŸš§ðŸš§ðŸš§

### Filter out...

For any particular application, some drives will drop out (like UX for DB), but not all the remaining combinations shall be taken into play and some may be detrimental.

For example, Development Driven/Crippled Design from the gross use of Test Driven Development.

##  Domain drive

### ... for all

If _domain-driven_ is a distinct approach there must be alternatives without that. **I doubt there are** &mdash; software as a phenomenon abstracts domains, explicitly or implicitly, nothing else. Domain Drive is a permanent force (like gravitation of abstractions).

One of the motives and benefits of object-oriented design is that it directly maps to domains, though one may break it with wrong and overladen hierarchies and bad naming.

> DDD-tempered code is adverse to names such as `utility`, `service`, `handler`, or `data` (unless these are conventions of platforms/frameworks).

#### ... <samp>REVERSE</samp> there?

**Yes**, remember the aphorism Â«_Computers solve problems that we didn't have without them_Â»? That's definitely about Operating Systems - Hardware/Software-Driven-Domain.

Many other  systems are projections of software possibilities that were rudimentary before mass computerization: ERP (as SAP), CRM, social networks, E-Mail, and blockchains.

### Test drive

**TDD** is the oldest and still most discussed (if not practiced) approach and earned its own corner in the [Tests area](../../tests).

To summarize
1) Test Driven **Development** and Test Driven **Design** are branching approaches.
2) Tests better qualify not as drives but as tools for Driven Development and Design.

#### Wrap up

This was a sketch, that shall be enhanced with references to live projects. Nevertheless, it may have spared you hours of rambling in courses and books.

ðŸ”š <sub>// image credit: [The Outer Limits.The&nbsp;Mutant, 1964](https://www.imdb.com/title/tt0667845/?ref_=ttep_ep25)</sub>
