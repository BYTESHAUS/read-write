# Software creation &mdash; Drives

What guides programming minds (and how) is a separate IT discipline. _Test-Driven Development_, _Domain-Driven Design_, and _Event-Driven Architecture_ are only a few household names for approaches. Functional programming is also a driven approach.

<details><summary><ins>&nbsp;<b>Adding more subjects and trying to combine them will roughly scheme a grotesque gearbox:</b>&nbsp;</ins></summary>
&nbsp;
  
<picture><img alt="&thinsp;&nbsp;&nbsp;Combinational mess of drives and driven" src="../../../_rsc/_img/illus/AllDrives.jpg"/></picture>

\___________
</details>

## Drive and let drive

Let's reserve <mark>&thinsp;one-way <b>1&thinsp;:&thinsp;1&thinsp;</b></mark> to voluminous books and techno-evangelists &mdash; they do a great job of formalization (including methodologies) and popularizing exclusive approaches, which may prevail in particular initiatives but can't be self-contained on praxis.

Our objective is to be neither dogmatic (don't take even this read as a doctrine) nor sticky to isolated combinations. The easiest path is to imagine the items (from the picture above) around your task and develop with approaches in mind.

The arduous trail is to draw arrows in the picture, play with their direction, and prioritize. Then continue designing naming and structures.

### Shift <samp>REVERSE</samp>

Consider any approach's counter "rotation," regardless of how twisted it looks first. For example, Development-Driven Tests are nothing more than test coverage (for automation).

<samp>REVERSE ENGINEERING</samp> is ... Code-Driven-Design! Design Driven Requirements makes Documentation.

ðŸš§ðŸš§ðŸš§... more EXAMPLES coming ... ðŸš§ðŸš§ðŸš§

### Filter out...

For any particular application, some drives will drop out (like UX for DB), but not all the remaining combinations shall be taken into play and some may be detrimental.

For example, Development Driven/Crippled Design from the gross use of Test Driven Development.

##  Domain drive

### ... for all

If _domain-driven_ is a distinct approach there must be alternatives without that. **I doubt there are** &mdash; software as a phenomenon abstracts domains, explicitly or implicitly, nothing else. Domain Drive is a permanent force (like gravitation of abstractions).

One of the motives and benefits of object-oriented design is that it directly maps to domains, though one may break it with wrong and overladen hierarchies and bad naming.

> DDD-tempered code is adverse to names such as `utility`, `service`, `handler`, or `data` (unless these are conventions of platforms/frameworks).

#### ... <samp>REVERSE</samp> there?

**Yes**, remember the aphorism Â«_Computers solve problems that we didn't have without them_Â»? That's definitely about Operating Systems - Hardware/Software-Driven-Domain.

Many software systems are projections of software possibilities that were rudimentary before mass computerization: ERP (as SAP), CRM, social networks, E-Mail, and blockchains.

### Tests

**TDD** is the oldest and still most discussed (if not practiced) approach and earned its own corner in the [Tests area](../../tests).

To summarize
1) Test Driven **Development** and Test Driven **Design** are branching approaches.
2) Tests are better seen not as drives but as tools for Implementation Driven Development and Domain Driven Design.

#### Wrap up

This was a sketch, that shall be enhanced with references to on-practice projects. Nevertheless, it might have spared you hours of rambling in courses and books.

ðŸ”š <sub>// image credit: [The Outer Limits.The&nbsp;Mutant, 1964](https://www.imdb.com/title/tt0667845/?ref_=ttep_ep25)</sub>
