# IT - Quotes - Cornerstones

[![ArcDeco thanks](https://img.shields.io/badge/‚≠ê-Arc_Deco-yellow?style=flat&labelColor=3A3B3C&color=yellow)](../../../../software/ArcDeco/README.md)

üî≤‚úÖ

![#architecture](https://img.shields.io/badge/%23-Architecture-yellow) ![#SimpleVsComplex](https://img.shields.io/badge/%23-Simple‚ûøcomp‚öîÔ∏èlex!-green)

<p dir="rtl">?What makes a good quote<br/>
.Terse, witty? ‚Äî  That's for aphorisms<br/>
.Brainy, ingenious? ‚Äî Prerequisites<br/>
.Context independent. ‚Äî The criterion</p>

That's why here you find a discernible inclination toward [IT pioneers](contributors/README.md#IT-Pioneers) whose, no better word, fundamental input to the theory **and** practice remained indisputable.<sup>:raising_hand:</sup> Both&nbsp;their&nbsp;foresights and delusions count.

Quotes and epigraphs can be annoying, but only worthy ones have been cherry-picked for this paper to provoke deeper IT thinking. Looking for quotes gets arduous - not every expert spoke/wrote/thought in them and maintained their list.

To keep the selection genuine I relocated sarcasm and dubiety to other chapters.

\_________

&nbsp;&nbsp;&nbsp;&nbsp;<sup>:raising_hand:</sup> <sub>Whose work backed up physicists and engineers of the Manhattan Project or Saturn, but not that popularized - only Turing got an A-movie (as far as I know).</sub>

## Aged good

> **Simplicity does not precede complexity but follows it.**\
[Alan Perlis](contributors/README.md#Alan-Perlis)

## Abstraction

> **The entire history of software engineering is that of the rise in levels of abstraction**.\
[Grady Booch](contributors/README.md#Grady-Booch), 2003

> **Data abstractions provide the same benefits as procedures but for data.**\
[Barbara Liskov](contributors/README.md#Barbara-Liskov)

> `AND` and `OR` are the basic operations of logic. Together with `NO` they are a complete set of basic logical operations ‚Äî **all other logical operations**, no matter how complex, **can be obtained by suitable combinations of these**.\
[John von Neumann](contributors/README.md#John-von-Neumann)

> **Without philosophy language design becomes hacking.**\
[Bjarne Stroustrup](contributors/README.md#Bjarne-Stroustrup)

> My ideal of program design is to represent the concepts of the application domain directly in code. 
That way, if you understand the application domain, you understand the code and vice versa.\
[Bjarne Stroustrup](contributors/README.md#Bjarne-Stroustrup)

[![ArcDeco thanks](https://img.shields.io/badge/‚≠ê-Arc_Deco-yellow?style=flat&labelColor=3A3B3C&color=yellow)](../../../../software/ArcDeco/README.md)
> The people at the bottom do not have the larger, global view, but at the top they do not have the local view of all the details, many of which can often be very important, so **either extreme gets poor results**.\
[Richard Hamming](contributors/README.md#Richard-Hamming)

> Science is what we understand well enough to explain to a **computer**. Art is everything else we do.\
[Donald Knuth](contributors/README.md#Donald-Knuth)

![#design](https://img.shields.io/badge/%23-Design-yellow) 

> There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no *obvious* deficiencies.\
&nbsp;\
The first method is far more difficult. It demands the same skill, devotion, insight, and even inspiration as the discovery of the simple physical laws which underlie the complex phenomena of nature.

![#design](https://img.shields.io/badge/%23-Design-yellow) 

> The art of programming is the art of organizing complexity, of mastering multitude and avoiding its bastard chaos as effectively as possible.\
[Edsger W. Dijkstra](contributors/README.md#Edsger-W-Dijkstra), 1970

![#design](https://img.shields.io/badge/%23-Methodolgy-yellow) 

> **Humans are allergic to change**. They love to say, "We've always done it this way."  **I try to fight that.**\
That's why I have a clock on my wall that runs counterclockwise.\
[Grace Hopper](contributors/README.md#Grace-Hopper)

### Docu and comments

> When you feel the need to write a comment, first try to refactor the code so **that any comment becomes superfluous**.\
[Kent Beck](contributors/README.md#Kent-Beck), "Refactoring", 1999

## Quality assurance

> **Testing shows the presence not the absence of bugs.**\
[Edsger W. Dijkstra](contributors/README.md#Edsger-W-Dijkstra), 1969 (documented while the saying appeared before)

> The key is to **test the areas that you are most worried about going wrong**. That way you get the most benefit for your testing effort. It is better to write and run incomplete tests than not to run complete tests.\
[Kent Beck](contributors/README.md#Kent-Beck), "Refactoring", 1999

{QA!!!}
> **I find it very odd.** I‚Äôm a fairly private person who just sits in front of the computer and hacks on code.\
_Andres Freund_, 2024, a programmer who occasionally prevented the "century" cyberattack, [NYT interview](https://www.nytimes.com/2024/04/03/technology/prevent-cyberattack-linux.html).

## Organisation

> A man provided with paper, pencil, and rubber, and subject to strict **discipline**, is in effect a universal machine.\
[Allan Turing](contributors/README.md#Allan-Turing) (1948)

> When I read commentary about suggestions for where C should go, I often think back and give thanks that it wasn`t developed under the advice of a worldwide crowd.\
[Dennis_Ritchie](contributors/README.md#Dennis-Ritchie)

> One of my guiding principles is **don‚Äôt do anything that other people are doing. Always do something a little different if you can.** The concept is that if you do it a little differently there is a greater potential for reward than if you the same thing that other people are doing. I think that this kind of goal for one‚Äôs work, having obviously the maximum risk, would have the maximum reward no matter what the field may be.\
[Seymour Cray](contributors/README.md#Seymour-Cray)

## Part 2/2. Aged not that good

<details><summary><b><ins>Skills</ins></b></summary>
&nbsp;
 
> Prolonged contact with the computer turns mathematicians into clerks and vice versa.\
[Alan Perlis](contributors/README.md#Alan-Perlis)

> Programming is one of the most difficult branches of applied mathematics; the poorer mathematicians had better remain pure mathematicians.\
[Edsger W. Dijkstra](contributors/README.md#Edsger-W-Dijkstra), 1975

The respected masters couldn't foresee the developing force's exponential growth and the entry threshold's dramatic sinking.

I venture to reformulate: "Most enough young and advanced in exact sciences can turn into good software developers but not vice versa".

---

</details>

<details><summary><b><ins>QA</ins></b></summary>
&nbsp;

> **If builders built houses the way programmers built programs, the first woodpecker to come along would destroy civilization.**\
Attributed to _Gerald Weinberg_

Knowing the high-responsibility software in which Mr.&nbsp;Weinberg participated one would strongly doubt his authorship. Or it was an explicit joke.

Despite all epic failures, software, on which our life depends, is extremely robust and contrary made the world safer. The aphorism shall better be: "If the software is built like houses, customers will wait decades for change requests.",

</details>

<details><summary><b><ins>Software</ins></b></summary>
&nbsp;

> In 30 years Lisp will likely be ahead of C++/Java (but behind something else).\
_Peter Norvig_, 1999

After 25 years Java is in the top five, C++ -- in 10, and where will be Lisp in the five remaining years?

\_______
 
</details>

<details><summary><b><ins>Hardware</ins></b></summary>
&nbsp;
 
> The programmer's primary weapon in the **never-ending battle against slow system** is to change the intramodular structure.\
_Fred Brooks_

I dare say that resources and performance are no longer a headache for the majority of applications.

> **Software gets slower faster than hardware gets faster.**\
[Niklaus Wirth](contributors/README.md#Niklaus-Wirth), 1995, "A Plea for Lean Software" (aka Wirth's law)

Much has changed since the 1990s when sparing half a byte was _bon ton_. Things like auto memory allocation with garbage collection and intermediate languages appeared only because the hardware could facilitate them.

</details>

## Controversial

<details><summary><b><ins>Maternity ward</ins></b></summary>

>  Everyone knows it takes a woman nine months to have a baby. But you Americans think if you get nine women pregnant, you can have a baby in a month.\
_Theodore von K√°rm√°n_ (1957)

It would be ok for this specific case but _Fred Brooks_ popularized it in [The Mythical Man-Month]()<sup>üîó</sup>:

> The bearing of a child takes nine months, no matter how many women are assigned.

Not only derogatory but illogical. Finding nine women in the vicinity who will deliver ten babies in half a month will take a couple of days. 

[Edsger W. Dijkstra](contributors/README.md#Edsger-W-Dijkstra) conveyed the idea much more plausible (albeit about languages, 1975):

> It is impossible to sharpen a pencil with a blunt axe. It is equally vain to try to do it with **ten** blunt axes instead.

(I could only add that the sharpest axes in clumsy hands may have already destroyed a pencil beyond repair.)

---

</details>

<details><summary><b><ins>Bad languages</ins></b></summary>
&nbsp;
 
> It is practically impossible to teach good programming to students that have had a prior exposure to **BASIC**: as potential programmers they are mentally mutilated beyond hope of regeneration.\
[Edsger W. Dijkstra](contributors/README.md#Edsger-W-Dijkstra), 1975

> C++ is a badly designed and ugly language. It would be a shame to use it in Emacs.\
_Richard Stallman_

> FORTRAN‚Äîthe "infantile disorder" by now nearly 20 years old, is hopelessly inadequate for whatever computer application you have in mind today: it is now too clumsy, too risky, and too expensive to use.\
[Edsger W. Dijkstra](contributors/README.md#Edsger-W-Dijkstra)

> <mark>C++ is a language strongly optimized for liars and people who go by guesswork and ignorance.</mark>\
_Erik Naggum_, Lisp programmer, 2008 on Usenet

Sure, an environment may force bad practices but they don't make developers.

</details>

<details><summary><b><ins>Paradigms</ins></b></summary>
 
> So programming languages on the whole are very much more complicated than they used to be: **object orientation, inheritance,** and other features are still not really being thought through from the point of view of a coherent and scientifically well-based discipline or a theory of correctness.\
...

_C.A.R. (Tony) Hoare_, 2002 in interview

<details><summary>Full quote...</summary>
 What‚Äôs happened is that practical programmers have used whatever understanding they‚Äôve gained, or theoreticians have offered them, to increase complexity. So programming languages on the whole are very much more complicated than they used to be: object orientation, inheritance, and other features are still not really being thought through from the point of view of a coherent and scientifically well-based discipline or a theory of correctness. My original postulate, which I have been pursuing as a scientist all my life, is that one uses the criteria of correctness as a means of converging on a decent programming language design‚Äîone which doesn‚Äôt set traps for its users, and ones in which the different components of the program correspond clearly to different components of its specification, so you can reason compositionally about it. Programming languages in full generality have not really paid full attention to this aspect. They tend to be defined purely on the basis of what the  29 machine does when it‚Äôs executing the program, and often at quite a low level of granularity too‚Äîindividual storage accesses. I still think we have to get the message across. The tools, including the compiler, have to be based on some theory of what it means to write a correct program.
</details>

</details>

## Misinterpreted and misattributed (disputed)

<details><summary><ins><b>&nbsp;Know the full story&nbsp;</b></ins></summary>
&nbsp;

> Where a calculator like ENIAC today is equipped with 18'000 vacuum tubes and weighs 30 tons, **computers in the future may** have only 1'000 vacuum tubes and perhaps **weigh only 1¬Ω tons**.\
_Popular Mechanics, March 1949_

Wrongly quoted as futuristic cringe, it wasn't.

The same magazine over seven decades later: "Fully transistorized computer, the IBM 608, hit the market in late 1957. It weighed 1.2 tons."

---

</details>

<details><summary><ins><b>&nbsp;Season with scepticism&nbsp;</b></ins></summary>
&nbsp;

> "There are only two kinds of languages: the ones people complain about and the ones nobody uses".\
Yes. Again, I very much doubt that the sentiment is original.\
Of course, all "there are only two" quotes have to be taken with a grain of salt.\
Bjarne Stroustrup*_ 

</details>

<details><summary><ins><b>&nbsp;Doomed to debug&nbsp;</b></ins></summary>
&nbsp;

> ... the realization came over me with full force that a good part of the remainder of my life was going to be spent in finding errors in my own programs.\
_Maurice Wilkes_

It's quoted sometimes as an appeal to quality but it's indeed a curious fact about the former hardware.

<details><summary>Full quote</summary>
 
> By June 1949 people had begun to realize that it was not so easy to get programs right as at one time appeared. I well remember when this realization first came on me with full force.
The EDSAC was on the top floor of the building and the tape-punching and editing equipment one floor below. [...] It was on one of my journeys between the EDSAC room and the punching equipment that "hesitating at the angles of stairs" the realization came over me with full force that a good part of the remainder of my life was going to be spent in finding errors in my own programs.

</details>

---

</details>
