# IT Quotes - Store - Backshelve

## Controversial

> Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program.\
[Linus Torvalds](../contributors/README.md#Linus-Torvalds)

Master _Torvalds_ could have meant renowned open-source contributors, but most smart guys in IT are for and because of wages and it's not fun in commercial development.

### Maternity ward

>  Everyone knows it takes a woman nine months to have a baby. But you Americans think if you get nine women pregnant, you can have a baby in a month.\
_Theodore von Kármán_ (1957)

It matched a private aviation engineering talk but [Fred Brooks](../contributors/README.md#Fred-Brooks) popularized the phrase in his [The Mythical Man-Month](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)<sup>🔗</sup>:

> The bearing of a child takes nine months, no matter how many women are assigned.

Not only derogatory but illogical. Finding nine women in the vicinity who will deliver ten babies in half a month is just a search. (Finding developers who can save a failing project is a question of payment.) 

[Edsger W. Dijkstra](../contributors/README.md#Edsger-W-Dijkstra) conveyed the idea much more plausible (albeit about languages, 1975):

> It is impossible to sharpen a pencil with a blunt axe. It is equally vain to try to do it with **ten** blunt axes instead.

(To add only that the sharpest axes in clumsy hands may have already destroyed pencils beyond repair.)

## Bitter words

### QA

<a id="woodpecker"></a>
> **If builders built houses the way programmers built programs, the first <mark>woodpecker</mark> to come along would destroy civilization.**\
Attributed to [Gerald Weinberg](../contributors/README.md#Gerald-Weinberg)

Knowing the high-responsibility software in which Mr.&nbsp;Weinberg participated one would strongly doubt his authorship. Or it was an explicit joke.

Despite all epic failures, software, on which our life depends, is extremely robust and contrary made the world safer. The aphorism shall better be: "If the software is built like houses, customers will wait decades for change requests."

### Languages
 
> It is practically impossible to teach good programming to students that have had a prior exposure to **BASIC**: as potential programmers they are mentally mutilated beyond hope of regeneration.\
[Edsger W. Dijkstra](../contributors/README.md#Edsger-W-Dijkstra), 1975

> **FORTRAN** &mdash; the "infantile disorder" by now nearly 20 years old, is hopelessly inadequate for whatever computer application you have in mind today: it is now too clumsy, too risky, and too expensive to use.\
[Edsger W. Dijkstra](../contributors/README.md#Edsger-W-Dijkstra)

> **C++** is a badly designed and ugly language. It would be a shame to use it in Emacs.\
[Richard Stallman](../contributors/README.md#Richard-Stallman)

> <mark><b>C++</b> is a language strongly optimized for liars and people who go by guesswork and ignorance.</mark> 🤦‍♂️\
_Erik Naggum_, Lisp programmer, 2008 on Usenet

Sure, an environment may force bad practices but they don't make developers.

### Paradigms
 
> So programming languages on the whole are very much more complicated than they used to be: **object orientation, inheritance,** and other features are still not really being thought through from the point of view of a coherent and scientifically well-based discipline or a theory of correctness.\
...

<details><summary><ins>&nbsp;Full quote...&nbsp;</ins></summary>
 <p>What’s happened is that practical programmers have used whatever understanding they’ve gained, or theoreticians have offered them, to increase complexity.</p>
<p>So programming languages on the whole are very much more complicated than they used to be: object orientation, inheritance, and other features are still not really being thought through from the point of view of a coherent and scientifically well-based discipline or a theory of correctness.</p>
<p>My original postulate, which I have been pursuing as a scientist all my life, is that one uses the criteria of correctness as a means of converging on a decent programming language design &mdash; one which doesn’t set traps for its users, and ones in which the different components of the program correspond clearly to different components of its specification, so you can reason compositionally about it.</p>
<p>Programming languages in full generality have not really paid full attention to this aspect. They tend to be defined purely on the basis of what the machine does when it’s executing the program, and often at quite a low level of granularity too &mdash; individual storage accesses.</p>
<p>I still think we have to get the message across. The tools, including the compiler, have to be based on some theory of what it means to write a correct program.</p>

\______

</details>

[C.A.R. (Tony) Hoare](../contributors/README.md#Tony-Hoare), in interview, 2002

🔚 but to be continued...
